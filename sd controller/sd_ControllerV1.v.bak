//===================================================================
// SD_Controller Testbench – FIXED MISO TIMING
//===================================================================
`timescale 1ns/1ps
module sd_controller_tb;

    reg clk = 0;
    always #10 clk = ~clk;

    reg rst_n;
    reg [511:0] write_data;
    reg write_data_ready;
    wire [511:0] read_data;
    wire read_ready;
    wire ready;
    wire spi_clk, spi_cs_n, spi_mosi;
    wire spi_miso;

    SD_Controller dut (
        .clk(clk), .rst_n(rst_n), .write_data(write_data),
        .write_data_ready(write_data_ready), .read_data(read_data),
        .read_ready(read_ready), .ready(ready),
        .spi_clk(spi_clk), .spi_cs_n(spi_cs_n), .spi_mosi(spi_mosi),
        .spi_miso(spi_miso)
    );

    wire [7:0] dut_state = dut.state;
    reg [7:0] last_state;
    always @(posedge clk) begin
        if (dut_state !== last_state) begin
            case (dut_state)
                8'd0:   $display("[%0t] STATE = S_IDLE", $time);
                8'd1:   $display("[%0t] STATE = S_POWERUP", $time);
                8'd2:   $display("[%0t] STATE = S_CMD0", $time);
                8'd3:   $display("[%0t] STATE = S_CMD0_WAIT", $time);
                8'd4:   $display("[%0t] STATE = S_CMD8", $time);
                8'd50:  $display("[%0t] STATE = S_RESP_WAIT", $time);
                8'd99:  $display("[%0t] STATE = S_ERROR", $time);
                default: $display("[%0t] STATE = %0d", $time, dut_state);
            endcase
            last_state <= dut_state;
        end
    end

    wire spi_clk_rising = dut.spi_clk_rise_reg;
    wire spi_clk_falling = dut.spi_clk_fall_reg;

    // SD Card Model
    reg [7:0] cmd_buf[0:5];
    reg [7:0] resp_buf[0:7];
    reg [7:0] data_byte;
    reg [2:0] bit_cnt;
    reg [2:0] cmd_idx;
    reg [2:0] resp_idx;
    reg [2:0] resp_bit_cnt;
    reg [6:0] data_idx;
    reg [7:0] resp_len;
    reg in_resp;
    reg in_data_tx;
    reg in_busy;
    integer i;
    reg card_ready;
    integer busy_cycles;
    reg write_token_seen;
    reg [6:0] write_byte_cnt;

    reg [15:0] powerup_clocks;
    initial begin
        powerup_clocks = 0;
        card_ready = 0;
        busy_cycles = 0;
        resp_len = 0;
        in_resp = 0;
        in_data_tx = 0;
        in_busy = 0;
        cmd_idx = 0;
        bit_cnt = 0;
        resp_idx = 0;
        resp_bit_cnt = 0;
        data_idx = 0;
        write_token_seen = 0;
        write_byte_cnt = 0;
        for (i = 0; i < 6; i = i + 1) cmd_buf[i] = 8'hFF;
        for (i = 0; i < 8; i = i + 1) resp_buf[i] = 8'hFF;
    end

    // Power-up
    always @(posedge clk) begin
        if (spi_cs_n && spi_clk_rising)
            if (powerup_clocks < 200)
                powerup_clocks = powerup_clocks + 1;
    end

    // Reset on CS high
    always @(posedge clk) begin
        if (spi_cs_n) begin
            cmd_idx <= 0;
            bit_cnt <= 0;
        end
    end

    // Capture command
    always @(posedge clk) begin
        if (spi_clk_rising && !spi_cs_n) begin
            cmd_buf[cmd_idx][7 - bit_cnt] = spi_mosi;
            bit_cnt = bit_cnt + 1;
            if (bit_cnt == 7) begin
                bit_cnt = 0;
                if (cmd_idx < 5)
                    cmd_idx = cmd_idx + 1;
                else begin
                    if (cmd_buf[0] == 8'h40 && cmd_buf[1] == 8'h00 && cmd_buf[2] == 8'h00 &&
                        cmd_buf[3] == 8'h00 && cmd_buf[4] == 8'h00 && cmd_buf[5] == 8'h95 &&
                        powerup_clocks >= 74) begin
                        resp_buf[0] = 8'h01;
                        resp_len = 1;
                        in_resp = 1;
                        resp_idx = 0;
                        resp_bit_cnt = 0;
                        $display("[%0t] CMD0 accepted → sending 0x01", $time);
                    end
                    else begin
                        decode_command;
                    end
                    cmd_idx = 0;
                end
            end
        end
    end

   //==============================================================
		// Update response bit counter on SPI rising edge
		//==============================================================
		always @(posedge clk) begin
			 if (spi_clk_rising && !spi_cs_n) begin
				  if (in_resp) begin
						resp_bit_cnt <= resp_bit_cnt + 1;
						if (resp_bit_cnt == 7) begin
						resp_bit_cnt <= 0;
						if (resp_idx < resp_len - 1)
							 resp_idx <= resp_idx + 1;
						else begin
							 in_resp <= 0;
							 resp_idx <= 0;
							 resp_len <= 0;
						end
						end
				  end
				  else if (in_data_tx) begin
						bit_cnt <= bit_cnt + 1;
						if (bit_cnt == 7) begin
							 bit_cnt <= 0;
							 data_idx <= data_idx + 1;
							 if (data_idx == 0) data_byte <= 8'hFE;
							 else if (data_idx <= 64) data_byte <= 8'hA5;
							 else data_byte <= 8'hFF;
							 if (data_idx == 66) in_data_tx <= 0;
						end
				  end
			 end
		end
		
		//==============================================================
		// COMBINATIONAL MISO
		//==============================================================
		assign spi_miso = (!spi_cs_n) ? (
			 in_resp ? resp_buf[resp_idx][7 - resp_bit_cnt] :
			 in_data_tx ? data_byte[7 - bit_cnt] :
			 in_busy ? 1'b0 : 1'b1
		) : 1'b1;

    // Write handling
    always @(posedge clk) begin
        if (write_token_seen && spi_clk_rising && !spi_cs_n && bit_cnt == 7) begin
            write_byte_cnt = write_byte_cnt + 1;
            if (write_byte_cnt == 63) begin
                resp_buf[0] = 8'h05; resp_len = 1; in_resp = 1;
                in_busy = 1; busy_cycles = 80;
                write_token_seen = 0;
                write_byte_cnt = 0;
            end
        end
    end

    always @(posedge clk) begin
        if (in_busy && busy_cycles > 0)
            busy_cycles = busy_cycles - 1;
        else if (busy_cycles == 0)
            in_busy = 0;
    end

    task decode_command;
        reg [5:0] cmd_index;
        reg [31:0] arg;
    begin
        cmd_index = cmd_buf[0][5:0];
        arg = {cmd_buf[1], cmd_buf[2], cmd_buf[3], cmd_buf[4]};
        if (cmd_buf[0][7:6] == 2'b01)
            $display("[%0t] CMD=%0d ARG=%08h CRC=%02h", $time, cmd_index, arg, cmd_buf[5]);

        if (cmd_index == 8) begin
            resp_buf[0] = 8'h01; resp_buf[1] = 8'h00; resp_buf[2] = 8'h00;
            resp_buf[3] = 8'h01; resp_buf[4] = 8'hAA; resp_len = 5; in_resp = 1;
        end
        else if (cmd_index == 55) begin
            resp_buf[0] = 8'h01; resp_len = 1; in_resp = 1;
        end
        else if (cmd_index == 41) begin
            card_ready = 1;
            resp_buf[0] = 8'h00; resp_len = 1; in_resp = 1;
        end
        else if (cmd_index == 58) begin
            resp_buf[0] = 8'h00; resp_buf[1] = 8'hC0; resp_buf[2] = 8'hFF;
            resp_buf[3] = 8'h80; resp_buf[4] = 8'h00; resp_len = 5; in_resp = 1;
        end
        else if (cmd_index == 16) begin
            resp_buf[0] = (arg == 64) ? 8'h00 : 8'h04; resp_len = 1; in_resp = 1;
        end
        else if (cmd_index == 17) begin
            resp_buf[0] = 8'h00; resp_len = 1; in_resp = 1;
            in_data_tx = 1; data_idx = 0; data_byte = 8'hFE;
        end
        else if (cmd_index == 24) begin
            resp_buf[0] = 8'h00; resp_len = 1; in_resp = 1;
            write_token_seen = 1; write_byte_cnt = 0;
        end
    end
    endtask

    initial begin
        $display("[%0t] *** SD_Controller 64-byte Testbench Start ***", $time);
        rst_n = 0; write_data_ready = 0;
        #200 rst_n = 1;
        @(posedge ready);
        $display("[%0t] SD Card initialized", $time);
        @(posedge read_ready);
        $display("[%0t] First read complete", $time);
        for (i = 0; i < 64; i = i + 1)
            if (read_data[511 - i*8 -: 8] !== 8'hA5) $stop;
        $display("Read data verified: 64 x 0xA5");
        write_data = 512'hDEADBEEF_CAFEBABE_12345678_90ABCDEF_11223344_55667788_99AABBCC_DDEEFF00;
        write_data_ready = 1; #20; write_data_ready = 0;
        @(posedge read_ready);
        $display("[%0t] Write-back read complete", $time);
        $display("Write-back %s", (read_data === write_data) ? "PASSED" : "FAILED");
        #2000;
        $display("=== 64-BYTE TESTBENCH PASSED ===");
        $finish;
    end

    initial begin
        $dumpfile("sd_64byte.vcd");
        $dumpvars(0, sd_controller_tb);
    end
endmodule