`timescale 1ns/1ps
module sd_encr_device_tb;

    // ------------------------------------------------------------
    // DUT ports
    // ------------------------------------------------------------
    reg  clk;
    reg  rst;
    reg  start;
    reg  rw_flag;          // 1 = encrypt (write), 0 = decrypt (read)
    wire done;

    // SD SPI pins (driven by testbench)
    wire sd_clk;
    wire sd_cs_n;
    wire sd_mosi;
    reg  sd_miso;

    // Key interface (external load)
    reg  key_rw;
    reg  key_sel;
    reg  [511:0] key_data_in;
    wire [511:0] key_data_out;

    // ------------------------------------------------------------
    // DUT instantiation
    // ------------------------------------------------------------
    sd_encr_device dut (
        .clk           (clk),
        .rst           (rst),
        .start         (start),
        .rw_flag       (rw_flag),
        .done          (done),

        .sd_clk        (sd_clk),
        .sd_cs_n       (sd_cs_n),
        .sd_mosi       (sd_mosi),
        .sd_miso       (sd_miso),

        .key_rw        (key_rw),
        .key_sel       (key_sel),
        .key_data_in   (key_data_in),
        .key_data_out  (key_data_out)
    );

    // ------------------------------------------------------------
    // Clock (50 MHz)
    // ------------------------------------------------------------
    initial clk = 0;
    always #10 clk = ~clk;

    // ------------------------------------------------------------
    // SPI byte capture (on falling edge of sd_clk)
    // ------------------------------------------------------------
    reg [7:0] captured_byte;
    reg [2:0] bit_cnt;
    reg       byte_valid;
    always @(negedge sd_clk or posedge sd_cs_n) begin
        if (sd_cs_n) begin
            bit_cnt     <= 3'd0;
            byte_valid  <= 1'b0;
        end else begin
            captured_byte <= {captured_byte[6:0], sd_mosi};
            bit_cnt       <= bit_cnt + 1'd1;
            if (bit_cnt == 3'd7) begin
                byte_valid <= 1'b1;
                $display("[%0t] SPI TX: 0x%h", $time,
                         {captured_byte[6:0], sd_mosi});
            end else begin
                byte_valid <= 1'b0;
            end
        end
    end

    // ------------------------------------------------------------
    // Helper tasks (Verilog-2001 only)
    // ------------------------------------------------------------
    task wait_bytes;
        input integer n;
        integer i;
        begin
            i = 0;
            while (i < n) begin
                @(posedge byte_valid);
                i = i + 1;
            end
        end
    endtask

    task send_r1;
        input [7:0] r;
        integer i;
        begin
            for (i = 7; i >= 0; i = i - 1) begin
                @(negedge sd_clk);
                sd_miso = r[i];
            end
        end
    endtask

    task send_token_fe;
        integer i;
        begin
            // 0xFE token
            @(negedge sd_clk); sd_miso = 1'b0;
            for (i = 0; i < 6; i = i + 1) @(negedge sd_clk) sd_miso = 1'b1;
            @(negedge sd_clk) sd_miso = 1'b1;
            @(negedge sd_clk) sd_miso = 1'b0;
        end
    endtask

    task send_data_resp_05;
        integer i;
        begin
            // Data response token = xxx00101  (0x05)
            for (i = 7; i >= 0; i = i - 1) begin
                @(negedge sd_clk);
                case (i)
                    7,6,4,3,1,0: sd_miso = 1'b0;
                    5,2:         sd_miso = 1'b1;
                endcase
            end
        end
    endtask

    // ------------------------------------------------------------
    // Main test sequence
    // ------------------------------------------------------------
    integer idx, j;
    reg [511:0] plain_block;
    reg [511:0] cipher_block;
    reg [511:0] key;
    reg [511:0] expected_cipher;
    reg [511:0] expected_plain;
    reg found_token;
    integer timeout;

    initial begin
        $display("=== sd_xor_device top-level testbench (Verilog-2001) ===");

        // --------------------------------------------------------
        // 0. Reset & initialise
        // --------------------------------------------------------
        rst         = 1;
        start       = 0;
        rw_flag     = 0;
        key_rw      = 0;
        key_sel     = 0;
        key_data_in = 512'd0;
        sd_miso     = 1;
        #200;
        rst = 0;
        #200;

        // --------------------------------------------------------
        // 1. Load a known 512-bit key (lower half of regfile)
        // --------------------------------------------------------
        key = 512'h0123_4567_89AB_CDEF_FEDC_BA98_7654_3210_
               1122_3344_5566_7788_99AA_BBCC_DDEE_FF00;
        key_rw   = 1;
        key_sel  = 0;           // lower 512 bits
        key_data_in = key;
        #20;
        key_rw = 0;
        $display("Key loaded (lower 512 bits)");

        // --------------------------------------------------------
        // 2. ENCRYPTION PATH
        // --------------------------------------------------------
        $display("\n--- ENCRYPTION TEST ---");

        // ---- Force SD controller into READ state (CMD17 already sent) ----
        force dut.u_sd_controller.state = dut.u_sd_controller.S_READ_TOKEN;
        force dut.u_sd_controller.waiting = 1'b0;
        release dut.u_sd_controller.state;
        release dut.u_sd_controller.waiting;

        // ---- Send token 0xFE + 64 data bytes (plain = 0x00,0x01,...,0x3F) ----
        plain_block = 512'd0;
        for (idx = 0; idx < 64; idx = idx + 1)
            plain_block[511 - 8*idx -: 8] = 8'(idx);

        send_token_fe();
        for (idx = 0; idx < 64; idx = idx + 1) begin
            for (j = 7; j >= 0; j = j - 1) begin
                @(negedge sd_clk);
                sd_miso = plain_block[511 - 8*idx + j];
            end
        end

        // ---- Trigger top-level start (encrypt) ----
        rw_flag = 1;          // encrypt
        start   = 1;
        #20;
        start   = 0;

        // ---- Wait for XOR to finish and SD to start write ----
        @(posedge done);
        $display("Encryption done signal received");

        // ---- SD controller now in WRITE_TOKEN state â†’ wait for 0xFE ----
        $display("Waiting for write token 0xFE...");
        found_token = 0;
        timeout = 0;
        while (!found_token && timeout < 200) begin
            @(posedge byte_valid);
            if (captured_byte === 8'hFE) begin
                $display("Write token 0xFE captured");
                found_token = 1;
            end else if (captured_byte !== 8'hFF) begin
                $error("Unexpected byte before token: 0x%h", captured_byte);
                $finish;
            end
            timeout = timeout + 1;
        end
        if (!found_token) begin
            $error("TIMEOUT waiting for 0xFE token");
            $finish;
        end

        // ---- Capture 64 ciphertext bytes and verify ----
        $display("Capturing 64 ciphertext bytes...");
        cipher_block = 512'd0;
        for (idx = 0; idx < 64; idx = idx + 1) begin
            @(posedge byte_valid);
            cipher_block[511 - 8*idx -: 8] = captured_byte;
        end

        // Expected ciphertext = plain XOR key
        expected_cipher = plain_block ^ key;
        if (cipher_block !== expected_cipher) begin
            $error("ENCRYPTION FAIL!");
            $display("  Got : %h", cipher_block);
            $display("  Exp : %h", expected_cipher);
            $finish;
        end else begin
            $display("ENCRYPTION SUCCESS! Ciphertext matches expected.");
        end

        // ---- Respond to write (R1 + data response + busy) ----
        send_r1(8'h00);
        send_data_resp_05();
        // 8 busy zeros + final 0xFF
        for (j = 0; j < 8; j = j + 1) begin
            @(negedge sd_clk); sd_miso = 1'b0;
        end
        @(negedge sd_clk); sd_miso = 1'b1;

        // --------------------------------------------------------
        // 3. DECRYPTION PATH (reuse same ciphertext)
        // --------------------------------------------------------
        $display("\n--- DECRYPTION TEST ---");

        // Force read of the just-written ciphertext
        force dut.u_sd_controller.state = dut.u_sd_controller.S_READ_TOKEN;
        force dut.u_sd_controller.waiting = 1'b0;
        release dut.u_sd_controller.state;
        release dut.u_sd_controller.waiting;

        send_token_fe();
        for (idx = 0; idx < 64; idx = idx + 1) begin
            for (j = 7; j >= 0; j = j - 1) begin
                @(negedge sd_clk);
                sd_miso = cipher_block[511 - 8*idx + j];
            end
        end

        // Trigger decryption
        rw_flag = 0;          // decrypt
        start   = 1;
        #20;
        start   = 0;

        @(posedge done);
        $display("Decryption done signal received");

        // Capture written plaintext
        found_token = 0;
        timeout = 0;
        while (!found_token && timeout < 200) begin
            @(posedge byte_valid);
            if (captured_byte === 8'hFE) begin
                $display("Write token 0xFE captured (decrypt)");
                found_token = 1;
            end else if (captured_byte !== 8'hFF) begin
                $error("Unexpected byte before token: 0x%h", captured_byte);
                $finish;
            end
            timeout = timeout + 1;
        end

        // Capture 64 bytes
        plain_block = 512'd0;
        for (idx = 0; idx < 64; idx = idx + 1) begin
            @(posedge byte_valid);
            plain_block[511 - 8*idx -: 8] = captured_byte;
        end

        // Expected plaintext = cipher XOR key = original plain
        expected_plain = cipher_block ^ key;
        if (plain_block !== expected_plain) begin
            $error("DECRYPTION FAIL!");
            $display("  Got : %h", plain_block);
            $display("  Exp : %h", expected_plain);
            $finish;
        end else begin
            $display("DECRYPTION SUCCESS! Plaintext restored.");
        end

        // Respond to write
        send_r1(8'h00);
        send_data_resp_05();
        for (j = 0; j < 8; j = j + 1) begin
            @(negedge sd_clk); sd_miso = 1'b0;
        end
        @(negedge sd_clk); sd_miso = 1'b1;

        // --------------------------------------------------------
        // Done
        // --------------------------------------------------------
        #1000;
        $display("=== ALL TESTS PASSED (Verilog-2001) ===");
        $finish;
    end

    // ------------------------------------------------------------
    // Timeout watchdog
    // ------------------------------------------------------------
    initial begin
        #50_000_000;
        $display("ERROR: TEST TIMEOUT");
        $finish;
    end

endmodule